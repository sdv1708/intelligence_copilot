================================================================================
EXECUTIVE INTELLIGENCE COPILOT - ARCHITECTURE DIAGRAM
================================================================================

SYSTEM OVERVIEW (MVP):

                            ┌─────────────────────────────┐
                            │   FRONTEND (Streamlit)      │
                            │  ┌──────────────────────┐   │
                            │  │ Sidebar              │   │
                            │  │ - Meeting Selector   │   │
                            │  │ - Upload/Paste       │   │
                            │  │ - Action Buttons     │   │
                            │  └──────────────────────┘   │
                            │  ┌──────────────────────┐   │
                            │  │ Main Content         │   │
                            │  │ - Brief Tabs         │   │
                            │  │ - Materials Table    │   │
                            │  └──────────────────────┘   │
                            └──────────────┬──────────────┘
                                           │
                           ┌───────────────┴────────────────┐
                           │ app.py (Orchestrator)          │
                           │ - State management             │
                           │ - Button callbacks             │
                           │ - Rendering                    │
                           └───────────┬────────┬───────────┘
                                       │        │
                   ┌───────────────────┘        └───────────────┐
                   │                                             │
         ┌─────────▼──────────┐                    ┌────────────▼────────┐
         │  ORCHESTRATION     │                    │  ORCHESTRATION      │
         │  (core modules)    │                    │  (core modules)     │
         │                    │                    │                     │
         │ • parsing.py       │                    │ • recall.py         │
         │ • chunk.py         │                    │ • synth.py          │
         │ • embed.py         │                    │ • db.py             │
         │                    │                    │                     │
         └─────────┬──────────┘                    └────────────┬────────┘
                   │                                             │
         ┌─────────▼──────────────────┐          ┌──────────────▼────────┐
         │  INPUT PROCESSING LAYER    │          │  OUTPUT LAYER         │
         │                            │          │                       │
         │ 1. Parse Files             │          │ 1. Retrieve Context   │
         │    └─ PDF/DOCX/PPTX/TXT   │          │    └─ Top-k chunks   │
         │                            │          │                       │
         │ 2. Chunk Text             │          │ 2. LLM Synthesis      │
         │    └─ 1200 char overlap   │          │    └─ Gemini API     │
         │                            │          │                       │
         │ 3. Embed Chunks           │          │ 3. Validate Output    │
         │    └─ MiniLM (384-dim)    │          │    └─ Pydantic JSON  │
         │                            │          │                       │
         └────────┬────────┬──────────┘          └──────────────┬────────┘
                  │        │                                      │
         ┌────────▼───┐    │                           ┌─────────▼────────┐
         │ STORAGE 1  │    │                           │ STORAGE 2        │
         │ SQLite DB  │    │                           │ MeetingBrief     │
         │            │    │                           │ (Pydantic)       │
         │ Tables:    │    │                           │                  │
         │ - meetings │    │                           │ - Recap          │
         │ - materials│◄───┼──── Save Text ────────►   │ - Action Items   │
         │ - briefs   │    │    & Metadata             │ - Key Topics     │
         │            │    │                           │ - Agenda         │
         └────────┬───┘    │                           │ - Evidence       │
                  │        │                           └──────────────────┘
                  │        │
                  │   ┌────▼──────────────┐
                  │   │ STORAGE 3         │
                  └──►│ FAISS Index       │
                      │                   │
                      │ - Per-meeting or  │
                      │   global namespace│
                      │ - Top-k search    │
                      │ - Similarity      │
                      │   scores          │
                      └───────────────────┘

================================================================================
DATA FLOW: END-TO-END PIPELINE
================================================================================

USER ACTION: "Upload PDF + Generate Brief"

Step 1: UPLOAD
  User selects PDF file in Streamlit
  ↓
  app.py → st.file_uploader() → file_bytes

Step 2: PARSE
  core/parsing.py::parse_file()
  ├─ Detect format (PDF)
  ├─ Call pypdf.PdfReader()
  ├─ Extract text (2,000+ chars)
  └─ Save metadata

Step 3: STORE MATERIAL
  core/db.py::add_material()
  ├─ Generate material_id
  ├─ INSERT into materials table
  ├─ Save filename, media_type, text
  └─ Return material_id

Step 4: CHUNK TEXT
  core/chunk.py::chunk_text()
  ├─ Split on sentence boundaries
  ├─ 1,200 chars per chunk
  ├─ 120 char overlap
  └─ Return list of ~5-10 chunks

Step 5: EMBED CHUNKS
  core/embed.py::encode()
  ├─ Detect GPU availability (CUDA)
  ├─ Load sentence-transformers model (lazy, on GPU if available)
  ├─ Convert chunks → 384-dim vectors (batch processing)
  ├─ Normalize embeddings
  └─ Return np.array (n_chunks, 384)

Step 6: INDEX EMBEDDINGS
  core/embed.py::add_to_index()
  ├─ Create FAISS index (if new)
  ├─ Add all embeddings
  ├─ Store metadata (material_id, chunk_idx)
  └─ Save index to disk

Step 7: RETRIEVE CONTEXT
  core/recall.py::recall_context()
  ├─ Build query embedding
  ├─ Search FAISS: top-k=8
  ├─ Return chunks + scores
  └─ Format as context blocks

Step 7.5: CHECK PREVIOUS MEETINGS (Optional)
  agents/copilot_orchestrator.py::_get_previous_meeting_context()
  ├─ Query meetings table for same title
  ├─ Get most recent brief
  ├─ Format previous meeting context
  └─ Return context string (or empty)

Step 8: PROMPT LLM
  agents/copilot_orchestrator.py::generate_brief()
  ├─ Load system + user prompts
  ├─ Substitute {{title}}, {{date}}, {{context}}
  ├─ Prepend previous meeting context if available
  ├─ Call LLM via LangChain (Gemini/GPT-4/Claude)
  └─ Parse JSON from response

Step 9: REPAIR & VALIDATE
  agents/copilot_orchestrator.py::generate_brief()
  ├─ Extract JSON from markdown code blocks
  ├─ Repair incomplete JSON (_repair_incomplete_json)
  ├─ Validate required fields, add defaults
  ├─ Validate JSON matches schema
  ├─ Instantiate MeetingBrief (Pydantic)
  ├─ Catch validation errors
  └─ Return or raise

Step 10: PERSIST
  core/db.py::save_brief()
  ├─ Generate brief_id
  ├─ Serialize MeetingBrief → JSON
  ├─ INSERT into briefs table
  └─ Return brief_id

Step 11: RENDER
  app.py (Streamlit callbacks)
  ├─ Display brief_json
  ├─ Populate tabs (Recap, Items, Topics, Agenda)
  ├─ Show evidence snippets
  └─ Display download buttons

Step 12: (Optional) DOWNLOAD
  core/db.py::get_brief_by_id()
  ├─ Fetch brief JSON
  ├─ Convert to markdown (optional)
  ├─ Trigger st.download_button()
  └─ User downloads file

QUERY: "What happened last time?"

  app.py → Button click
  ↓
  core/db.py::get_latest_brief()
  ├─ Query briefs table
  ├─ WHERE meeting_id = X
  ├─ ORDER BY created_at DESC LIMIT 1
  └─ Return MeetingBrief JSON
  ↓
  app.py → Render same as Step 11

================================================================================
KEY COMPONENTS INTERACTION
================================================================================

1. PARSING LAYER
   Input: File bytes or text string
   ├─ parsing.py: Detect format → extract text
   ├─ Returns: (text, media_type)
   └─ Output: Plain text (2,000-50,000 chars)

2. CHUNKING LAYER
   Input: Plain text (2,000+ chars)
   ├─ chunk.py: Split on boundaries → overlap
   ├─ Returns: List of chunks
   └─ Output: ~5-50 chunks × 1,200 chars each

3. EMBEDDING LAYER (with GPU acceleration)
   Input: Chunks (list of strings)
   ├─ embed.py: MiniLM model → embeddings
   ├─ GPU detection and automatic device selection
   ├─ Batch processing (64 on GPU, 16 on CPU)
   ├─ Returns: np.array (n, 384)
   └─ Output: Dense vectors (GPU-accelerated if available)

4. INDEXING LAYER
   Input: Dense vectors
   ├─ embed.py + FAISS: Build/add to index
   ├─ Returns: FAISS index
   └─ Output: *.index file on disk

5. RETRIEVAL LAYER
   Input: Query (meeting_id)
   ├─ recall.py: Query embedding → top-k search
   ├─ Returns: List of relevant chunks
   └─ Output: Context blocks + scores

6. CROSS-MEETING MEMORY LAYER
   Input: Current meeting title
   ├─ orchestrator.py: _get_previous_meeting_context()
   ├─ Find meetings with same title
   ├─ Retrieve previous brief
   ├─ Format: recap, action items, topics
   └─ Output: Previous meeting context string

6.5. SYNTHESIS LAYER
   Input: Context blocks + meeting details + previous meeting context
   ├─ orchestrator.py: Format prompt → LLM API (LangChain)
   ├─ LLM: Gemini 2.5 Flash Lite / GPT-4 / Claude 3.5 Sonnet
   ├─ JSON repair logic for incomplete responses
   ├─ Field validation and defaults
   ├─ Returns: MeetingBrief JSON
   └─ Output: Structured brief

7. PERSISTENCE LAYER
   Input: MeetingBrief object
   ├─ db.py: Serialize → INSERT into DB
   ├─ Returns: brief_id
   └─ Output: SQLite record

8. PRESENTATION LAYER
   Input: MeetingBrief object
   ├─ app.py: Render in Streamlit
   ├─ Returns: UI components
   └─ Output: User-visible brief

================================================================================
DATABASE SCHEMA
================================================================================

TABLE: meetings
┌─────────────┬─────────┬──────────────────────────────┐
│ Column      │ Type    │ Purpose                      │
├─────────────┼─────────┼──────────────────────────────┤
│ id (PK)     │ TEXT    │ Unique meeting ID            │
│ title       │ TEXT    │ Meeting title                │
│ date        │ TEXT    │ Meeting date (ISO format)    │
│ attendees   │ TEXT    │ Comma-separated list         │
│ tags        │ TEXT    │ Comma-separated tags         │
│ created_at  │ TEXT    │ Creation timestamp (ISO)     │
└─────────────┴─────────┴──────────────────────────────┘

TABLE: materials
┌─────────────┬─────────┬──────────────────────────────┐
│ Column      │ Type    │ Purpose                      │
├─────────────┼─────────┼──────────────────────────────┤
│ id (PK)     │ TEXT    │ Unique material ID           │
│ meeting_id  │ TEXT    │ Foreign key to meetings      │
│ filename    │ TEXT    │ Original filename            │
│ media_type  │ TEXT    │ pdf/docx/pptx/txt/pasted    │
│ text        │ TEXT    │ Extracted text              │
│ created_at  │ TEXT    │ Upload timestamp            │
└─────────────┴─────────┴──────────────────────────────┘

TABLE: briefs
┌─────────────┬─────────┬──────────────────────────────┐
│ Column      │ Type    │ Purpose                      │
├─────────────┼─────────┼──────────────────────────────┤
│ id (PK)     │ TEXT    │ Unique brief ID              │
│ meeting_id  │ TEXT    │ Foreign key to meetings      │
│ created_at  │ TEXT    │ Generation timestamp        │
│ model       │ TEXT    │ LLM model used               │
│ brief_json  │ TEXT    │ Serialized MeetingBrief     │
└─────────────┴─────────┴──────────────────────────────┘

================================================================================
PYDANTIC SCHEMA
================================================================================

MeetingBrief
├─ meeting_title: str
├─ time_window: Optional[str]
├─ last_meeting_recap: str
├─ open_action_items: List[ActionItem]
│  ├─ owner: str
│  ├─ item: str
│  ├─ due: Optional[str]
│  └─ status: Literal["open", "blocked", "done"]
├─ key_topics_today: List[str]
├─ proposed_agenda: List[AgendaItem]
│  ├─ topic: str
│  ├─ minutes: int
│  └─ owner: Optional[str]
└─ evidence: List[Evidence]
   ├─ source: str (format: "material_id#c{chunk_idx}")
   └─ snippet: str

================================================================================
ENVIRONMENT VARIABLES
================================================================================

GEMINI_API_KEY (Required for Gemini)
  └─ Google Gemini API key from console.cloud.google.com
  └─ Used by: core/llm_providers.py (via LangChain)

OPENAI_API_KEY (Required for OpenAI)
  └─ OpenAI API key
  └─ Used by: core/llm_providers.py (via LangChain)

ANTHROPIC_API_KEY (Required for Claude)
  └─ Anthropic API key
  └─ Used by: core/llm_providers.py (via LangChain)

LLM_PROVIDER (Optional, default: "gemini")
  └─ Set to "gemini", "openai", or "anthropic"
  └─ Used by: agents/copilot_orchestrator.py

DB_PATH (Optional, default: "./data/briefs.db")
  └─ Path to SQLite database file
  └─ Used by: core/db.py

FAISS_PATH (Optional, default: "./data/faiss")
  └─ Directory for FAISS index files
  └─ Used by: core/embed.py

================================================================================
STREAMLIT STATE & CALLBACKS
================================================================================

Streamlit Session State (st.session_state):
├─ current_meeting_id: str (selected meeting)
├─ generated_brief: Optional[MeetingBrief]
├─ uploaded_files: List[UploadedFile]
├─ pasted_text: str
└─ materials: List[Dict] (from DB)

Callbacks:
├─ on_create_meeting() → db.create_meeting() → state update
├─ on_select_meeting(id) → state update → fetch materials
├─ on_upload_files() → parsing → db.add_material() → state update
├─ on_paste_text() → db.add_material() → state update
├─ on_generate_brief() → recall → synth → db.save_brief() → state update
├─ on_recall_memory() → db.get_latest_brief() → state update
└─ on_download_brief() → serialize to JSON/MD → download

================================================================================
ERROR HANDLING FLOW
================================================================================

Try-Except Blocks (all major operations):

1. FILE PARSING
   ├─ Try: extract text
   ├─ Except: log error, return ""
   └─ UI: show warning, continue with other files

2. EMBEDDING
   ├─ Try: load model, encode chunks
   ├─ Except: log error, return empty array
   └─ UI: show warning, disable generation

3. API CALL
   ├─ Try: call Gemini
   ├─ Except (429): retry with backoff (max 3)
   ├─ Except (5xx): retry once, fail gracefully
   ├─ Except (other): log + show user error
   └─ UI: show error toast

4. VALIDATION
   ├─ Try: instantiate MeetingBrief
   ├─ Except: log fields that failed validation
   └─ UI: show which fields missing, allow manual correction

5. DATABASE
   ├─ Try: INSERT/SELECT/UPDATE
   ├─ Except: log error, don't crash
   └─ UI: show non-fatal warning

================================================================================
PERFORMANCE TARGETS
================================================================================

Parsing (large PDF):        < 2 sec
Chunking (10 chunks):       < 100 ms
Embedding (10 chunks):      < 1 sec CPU / < 0.2 sec GPU (model load ~5 sec first time)
FAISS indexing:             < 500 ms
Vector search (top-8):      < 100 ms
LLM call (context → brief): 5-15 sec
Brief rendering:            < 500 ms
Database operations:        < 100 ms each

TOTAL PIPELINE (end-to-end):  7-20 seconds
TARGET: < 15 seconds for typical meeting (2 files)

================================================================================
TESTING STRATEGY
================================================================================

Unit Tests (Per Module):
├─ parsing.py: test all 4 formats + error cases
├─ chunk.py: verify chunk sizes, overlaps
├─ embed.py: verify embedding shape, FAISS ops
├─ recall.py: verify top-k results
├─ synth.py: mock Gemini, test JSON parsing
├─ db.py: test CRUD operations
└─ schema.py: test validation pass/fail

Integration Tests (Full Pipeline):
├─ Upload PDF → see materials
├─ Upload + Generate → valid brief
├─ Save → Recall → same brief
├─ Download JSON → valid format

E2E Tests (User Flow):
├─ Create meeting → Upload → Generate → Download
├─ Recall memory → verify correct brief
├─ Multiple meetings → switch between

Performance Tests:
├─ Large file (10MB) → measure time
├─ Many chunks (100+) → measure time
├─ Concurrent requests → measure stability

================================================================================

